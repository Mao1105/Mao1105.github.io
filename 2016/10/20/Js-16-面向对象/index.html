<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Js第十六章-面向对象(一)【10.20】 | 花西凉凉</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="6.1理解对象ECMAScript有两种开发模式：
1. 函数式(过程化)2. 面向对象(OOP)。
面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。
6.2创建对象在JavaScript中，创建对象的方式包括两种：对象字面量和使用new表达式。对象字面量是一种灵活方便">
<meta property="og:type" content="article">
<meta property="og:title" content="Js第十六章-面向对象(一)【10.20】">
<meta property="og:url" content="http://yoursite.com/2016/10/20/Js-16-面向对象/index.html">
<meta property="og:site_name" content="花西凉凉">
<meta property="og:description" content="6.1理解对象ECMAScript有两种开发模式：
1. 函数式(过程化)2. 面向对象(OOP)。
面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。
6.2创建对象在JavaScript中，创建对象的方式包括两种：对象字面量和使用new表达式。对象字面量是一种灵活方便">
<meta property="og:updated_time" content="2016-10-20T10:43:42.368Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Js第十六章-面向对象(一)【10.20】">
<meta name="twitter:description" content="6.1理解对象ECMAScript有两种开发模式：
1. 函数式(过程化)2. 面向对象(OOP)。
面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。
6.2创建对象在JavaScript中，创建对象的方式包括两种：对象字面量和使用new表达式。对象字面量是一种灵活方便">
  
    <link rel="alternative" href="/atom.xml" title="花西凉凉" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="Mao1105.github.io/2066B08EEAB6C328D8977451F7C073BD.jpg " class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">花西凉凉</a></h1>
		</hgroup>

		
		<p class="header-subtitle">我自是年少，韶华倾负</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/Mao1105" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/5022513426" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/missingmao" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="/1354331621@qq.com" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">花西凉凉</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="Mao1105.github.io/2066B08EEAB6C328D8977451F7C073BD.jpg " class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">花西凉凉</h1>
			</hgroup>
			
			<p class="header-subtitle">我自是年少，韶华倾负</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Mao1105" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5022513426" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/missingmao" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="/1354331621@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-Js-16-面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Js第十六章-面向对象(一)【10.20】
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="6-1理解对象"><a href="#6-1理解对象" class="headerlink" title="6.1理解对象"></a>6.1理解对象</h1><p><strong>ECMAScrip</strong>t有两种开发模式：</p>
<p><strong>1. 函数式(过程化)</strong><br><strong>2. 面向对象(OOP)。</strong></p>
<p>面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。</p>
<h1 id="6-2创建对象"><a href="#6-2创建对象" class="headerlink" title="6.2创建对象"></a>6.2创建对象</h1><p>在JavaScript中，创建对象的方式包括两种：对象字面量和使用new表达式。对象字面量是一种灵活方便的书写方式，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;</div><div class="line">    <span class="attr">p</span>:”I’m <span class="keyword">in</span> <span class="built_in">Object</span> literal”,</div><div class="line">    <span class="attr">alertP</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 这样，就用对象字面量创建了一个对象<strong>o1</strong>，它具有一个<strong>成员变量p</strong>以及一个<strong>成员方法alertP</strong>。这种写法的<em>缺点</em>是，每创建一个新的对象都需要写出完整的定义语句，不便于创建大量相同类型的对象，不利于使用继承等高级特性。</p>
<p>++new表达式是配合构造函数使用的++，例如new String(“a string”)，调用内置的String函数构造了一个字符串对象。下面我们用构造函数的方式来重新创建一个实现同样功能的对象，首先是定义构造函数，然后是调用new表达式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CO</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.p = “I’m <span class="keyword">in</span> constructed object”;</div><div class="line">    <span class="keyword">this</span>.alertP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.p);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o2 = newCO();</div></pre></td></tr></table></figure></p>
<h2 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1 工厂模式"></a>6.2.1 工厂模式</h2><p>直接在一个函数内定义一个对象,并返回经过处理后的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//工厂模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();                                 <span class="comment">//创建对象</span></div><div class="line">    obj.name = name;                                            <span class="comment">//添加属性</span></div><div class="line">    obj.age = age;</div><div class="line">    obj.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                                     <span class="comment">//添加方法</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">'运行中...'</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj;                                                     <span class="comment">//返回对象引用</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject2</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();                                 <span class="comment">//创建对象</span></div><div class="line">    obj.name = name;                                            <span class="comment">//添加属性</span></div><div class="line">    obj.age = age;</div><div class="line">    obj.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                                     <span class="comment">//添加方法</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">'运行中...'</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj;                                                     <span class="comment">//返回对象引用</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> box1 = createObject(<span class="string">'Lee'</span>, <span class="number">100</span>);                    <span class="comment">//创建第一个对象</span></div><div class="line"><span class="keyword">var</span> box2 = createObject(<span class="string">'Jack'</span>, <span class="number">200</span>);                   <span class="comment">//创建第二个对象</span></div><div class="line"><span class="keyword">var</span> box3 = createObject2(<span class="string">'kkk'</span>, <span class="number">500</span>);                   <span class="comment">//创建第三个对象</span></div><div class="line"></div><div class="line"><span class="comment">//alert(box1.run());                                                    //打印第一个对象实例的run()方法</span></div><div class="line"><span class="comment">//alert(box2.run());                                                    //打印第二个对象实例的run()方法</span></div><div class="line"></div><div class="line"><span class="comment">//alert(typeof box1);</span></div><div class="line"><span class="comment">//alert(typeof box2);</span></div><div class="line">alert(box1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">alert(box2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">alert(box3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                      <span class="comment">//不管怎样，他们都是Object类型，就无法区分，谁到底是谁的对象了</span></div></pre></td></tr></table></figure></p>
<h2 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2 构造函数模式"></a>6.2.2 构造函数模式</h2><p><strong>构造函数的使用</strong>：用于创建一个特定类型的对象。<br><strong>构造函数规则</strong>：</p>
<ul>
<li><p><strong>Java</strong>:</p>
<ol>
<li><p>构造器必须与类同名（如果一个源文件中有多个类，那么构造器必须与公共类同名）</p>
</li>
<li><p>每个类可以有一个以上的构造器</p>
</li>
<li><p>构造器可以有0个、1个或1个以上的参数</p>
</li>
<li><p>构造器没有返回值</p>
</li>
<li><p>构造器总是伴随着new操作一起调用</p>
</li>
</ol>
</li>
<li><p><strong>javascript</strong></p>
<ol>
<li>函数名和实例化构造名相同且大写，(PS：非强制，但这么写有助于区分构造函数和普通函数)；</li>
<li>通过构造函数创建对象，必须使用new运算符。</li>
</ol>
</li>
</ul>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">name, age</span>) </span>&#123;               <span class="comment">//构造函数模式</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">'运行中...'</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> box1 = <span class="keyword">new</span> Box(<span class="string">'Lee'</span>, <span class="number">100</span>); <span class="comment">//new Box()即可</span></div><div class="line"><span class="keyword">var</span> box2 = <span class="keyword">new</span> Box(<span class="string">'Jack'</span>, <span class="number">200</span>);</div><div class="line"><span class="keyword">var</span> box3 = <span class="keyword">new</span> Box(<span class="string">'Jack'</span>, <span class="number">200</span>);</div><div class="line">alert(box1.run());</div><div class="line">alert(box1 <span class="keyword">instanceof</span> Box);             <span class="comment">//很清晰的识别他从属于Box</span></div></pre></td></tr></table></figure></p>
<p><strong>构造函数执行过程</strong>：</p>
<ol>
<li>当使用了构造函数，并且new 构造函数()，那么就后台执行了new Object()；（构造函数没有new Object，但它后台会自动var obj = new Object）</li>
<li>将构造函数的作用域给新对象，(即new Object()创建出的对象)，而函数体内的this就代表new Object()出来的对象obj。</li>
<li>执行构造函数内的代码；</li>
<li>返回新对象(构造函数不需要返回对象引用，它是后台自动返回的)。</li>
</ol>
<p><strong>注意</strong>:</p>
<p>1.构造函数用普通函数方法调用是无效的！<br>即任何函数，只要通过new操作符来调用，那他就可以作为构造函数；否则就可以当作一个普通函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Box(<span class="string">'小红'</span>,<span class="number">20</span>)) <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>2.box1,box2,分别保存着一个不同的Box实例，这两个对象都有着一个<strong>constructor</strong>(构造函数)属性，属性指向Box.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(box3.constructor==box4.constructor);<span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p><strong>构造函数缺点</strong>：<br>每个方法都要在每个实例中重新创建一遍。即不同实例上的同名函数是不相等的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(box2.run==box3.run);//false</div></pre></td></tr></table></figure></p>
<p><strong>解决方法</strong>：<br>在全局定义一个全局函数，并绑定到构造函数中,此时run包含的是一个指向外部函数的指针，box2,box3共享同一个全局函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个对象，所有构造函数的对象其实就是Object</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">user, age</span>) </span>&#123;           </div><div class="line">    <span class="keyword">this</span>.user = user;<span class="comment">//添加一个属性</span></div><div class="line">    <span class="keyword">this</span>.age = age;         </div><div class="line">    <span class="keyword">this</span>.run = run;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//把构造函数内部的方法通过全局来实现引用地址一致</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;                        </div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.user + <span class="keyword">this</span>.age + <span class="string">'运行中...'</span>;</div><div class="line">&#125;</div><div class="line">alert(box2.run==box3.run);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><strong>问题又来了</strong>：如果对象要定义很多方法，需要定义很多全局函数！！<br>那么就需要用到<strong>原型模式</strong>。</p>
<h2 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h2><p>在ECMAScript中，函数是一个对象。每个对象都有一个<strong>prototype(原型)</strong> 属性，这个属性是一个指针，指向另一个对象，而这另一个对象的用途是包含可以由特定类型的搜游实例共享的属性和方法。<br>字面意思：prototype就是通过调用构造函数调用的那个实例的原型对象,所有对象实例共享它所包含的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>) </span>&#123;&#125;   <span class="comment">//声明一个构造函数</span></div><div class="line"></div><div class="line">Box.prototype.name = <span class="string">'Lee'</span>;<span class="comment">//在原型里添加属性</span></div><div class="line">Box.prototype.age = <span class="number">100</span>;                    </div><div class="line">Box.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//在原型里添加方法</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">'运行中...'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//比较一下原型内的方法地址是否一致：</span></div><div class="line"><span class="keyword">var</span> box1 = <span class="keyword">new</span> Box();</div><div class="line"><span class="keyword">var</span> box2 = <span class="keyword">new</span> Box();</div><div class="line">alert(box1.run == box2.run);<span class="comment">//true，方法的引用地址保持一致</span></div></pre></td></tr></table></figure></p>
<p>在原型模式声明中，多了两个属性，这两个属性都是创建对象时自动生成的。<strong>proto</strong>属性是实例指向原型对象的一个指针，它的作用就是指向构造函数的原型属性constructor。通过这两个属性，就可以访问到原型里的属性和方法了。<br>PS：IE浏览器在脚本访问<strong>proto</strong>会不能识别，火狐和谷歌浏览器及其他某些浏览器均能识别。虽然可以输出，但无法获取内部信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(box1.__proto__);<span class="comment">//[object Object]</span></div><div class="line">alert(box1.prototype);<span class="comment">//undefind</span></div><div class="line">alert(Box.prototype);<span class="comment">//[object Object]</span></div></pre></td></tr></table></figure></p>
<p><strong>原型模式的执行流程：</strong></p>
<ol>
<li>先查找构造函数实例里的属性或方法，如果有，立刻返回；</li>
<li>如果构造函数实例里没有，则去它的原型对象里找，如果有，就返回</li>
</ol>
<p><strong>注意：</strong><br><strong>delete box1.name;</strong> 可以删除实力中的属性，但不影响原型属性。原型中的属性不能通过实例对象重写。</p>
<ul>
<li><p>判断一个对象是否指向了该构造函数的原型对象，可以使用<strong>isPrototypeOf()</strong> 方法来测试。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Box.prototype.isPrototypeOf(box1);<span class="comment">//true 只要实例化对象，即都会指向Box 返回true</span></div></pre></td></tr></table></figure>
</li>
<li><p>判断属性是在实例中还是原型中：可以使用<strong>hasOwnProperty()</strong> 函数来验证：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(box1.hasOwnProperty(<span class="string">'name'</span>));<span class="comment">//实例里有返回true，否则返回false</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>in</strong>操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="string">'name'</span> <span class="keyword">in</span> box1);<span class="comment">//true，不管存在实例中或原型中，只要有就返回true</span></div></pre></td></tr></table></figure>
</li>
<li><p>ECMAScript5提供新方法<strong>获取原型：Object.getPrototypeOf();</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(box2)==Box.prototype)<span class="comment">//true</span></div><div class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(box2).name)<span class="comment">//Lee</span></div></pre></td></tr></table></figure>
</li>
<li><p>获取对象上所有实例属性：<strong>Object.keys();</strong> 接受一个对象，返回该对象的所有可枚举实例属性(一串字符)。</p>
</li>
<li><p><strong>Object.getOwnPropertyNames()</strong> 返回所有属性，可以代替for-in循环</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Fn.prototype.name=<span class="string">'mao'</span>;</div><div class="line">Fn.prototype.age=<span class="string">'10'</span>;</div><div class="line">Fn.prototype.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn1=<span class="keyword">new</span> Fn();</div><div class="line">fn1.name=<span class="string">'wang'</span>;</div><div class="line">fn1.age=<span class="string">'18'</span>;</div><div class="line">alert(<span class="built_in">Object</span>.keys(fn1))<span class="comment">//name,age</span></div><div class="line">alert(<span class="built_in">Object</span>.getOwnPropertyNames(fn1))<span class="comment">//name age</span></div><div class="line">alert(<span class="built_in">Object</span>.keys(Fn.prototype))<span class="comment">//name,age,run</span></div><div class="line">alert(<span class="built_in">Object</span>.getOwnPropertyNames(Fn.prototype))<span class="comment">//constructor,name,age,run</span></div></pre></td></tr></table></figure>
</li>
<li><p>简化原型语法–使用字面量添加属性：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Box.prototype = &#123;                       <span class="comment">//使用字面量的方式</span></div><div class="line">    name : <span class="string">'Lee'</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">100</span>,</div><div class="line">    <span class="attr">run</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">'运行中...'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>  字面量创建的方式使用constructor属性不会指向实例，而会指向Object，构造函数创建的方式则相反。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ar box = <span class="keyword">new</span> Box();</div><div class="line">alert(box <span class="keyword">instanceof</span> Box);</div><div class="line">alert(box <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">alert(box.constructor == Box)<span class="comment">//字面量方式，返回false，否则，true</span></div><div class="line">alert(box.constructor == <span class="built_in">Object</span>);           <span class="comment">//字面量方式，返回true，否则，false</span></div><div class="line"></div><div class="line"><span class="comment">//如果想让字面量方式的constructor指向实例对象，那么可以这么做：</span></div><div class="line">Box.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span> : Box,  <span class="comment">//直接强制指向即可</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>  PS：字面量方式为什么constructor会指向Object？因为Box.prototype={};这种写法其实就是创建了一个新对象。而每创建一个函数，就会同时创建它prototype，这个对象也会自动获取constructor属性。所以，新对象的constructor重写了Box原来的constructor，因此会指向新对象，那个新对象没有指定构造函数，那么就默认为Object。</p>
<p>  原型的声明是有先后顺序的，所以，重写的原型会切断之前的原型。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Box()&#123;&#125;;</div><div class="line">//原型被重写了</div><div class="line">Box.prototype = &#123;</div><div class="line">    constructor : Box,</div><div class="line">    name : &apos;Lee&apos;,</div><div class="line">    age : 100,</div><div class="line">    run : function () &#123;</div><div class="line">        return this.name + this.age + &apos;运行中...&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">ar box = new Box();</div><div class="line">alert(box.age)//100 此时原型并未改写</div><div class="line">Box.prototype = &#123;</div><div class="line">    age :200</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var box = new Box();//在这里声明</div><div class="line">alert(box.age)//200</div><div class="line">alert(box.run());//最初原型被切断，直接指向改写后的原型</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/20/Js-16-面向对象/" class="archive-article-date">
  	<time datetime="2016-10-20T10:39:44.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-20</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2016/10/20/Js笔记：第15章-使用Canvas绘图（一） 10.18/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Js第十五章-canvas(一)【10.18】</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">-=0【怕；
var duoshuoQuery = {short_name:"mao1105"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 花西凉凉
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">一个集美貌与才华于一身的&lt;br&gt;好姑娘&lt;br&gt;&lt;br&gt;毕业于河大计算机系&lt;br&gt;热爱前端，爱吃海带&lt;br&gt;&lt;br&gt;相忘谁先忘，倾国是故国。&lt;br&gt;泠泠不肯弹，蹁跹影惊鸿</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>